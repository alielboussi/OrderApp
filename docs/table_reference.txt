Afterten Orders Data Dictionary
===============================

catalog_items
-------------
Stores master product definitions that every downstream table references. Required columns: `name`, `consumption_uom`, `purchase_pack_unit`, `units_per_purchase_pack`, and booleans like `has_variations` and `active`. Optional SKU, cost, default warehouse mapping, and the purchase metadata (`purchase_unit_mass`, `purchase_unit_mass_uom`, `transfer_unit`, `transfer_quantity`) live here as well.

catalog_variants
----------------
Child records tied to `catalog_items` via `item_id`. Represents each pack size or variation; now duplicates the purchase pack metadata (`purchase_pack_unit`, `units_per_purchase_pack`, `purchase_unit_mass`, `transfer_unit`, `transfer_quantity`) alongside consumption defaults. `default_warehouse_id` lets you override the item-level default when allocating inventory.

item_ingredient_recipes
-----------------------
Maps finished goods to ingredient SKUs for pack production or BOM deductions. `finished_item_id`/`finished_variant_id` point to the parent, while `ingredient_item_id` plus `qty_per_unit` describe what to deduct per produced unit. `source_warehouse_id` locks each ingredient to the warehouse that should supply the grams/ml/units. Used by the `record_outlet_sale` function when `is_production` is true.

item_transfer_profiles
----------------------
Defines default movement settings between two warehouses for a specific SKU/variation. Captures `from_warehouse_id`, `to_warehouse_id`, the transfer unit label, and the quantity that should auto-fill transfer scanners.

item_warehouse_handling_policies
--------------------------------
Scopes deduction logic per warehouse. Stores `deduction_uom`, an optional `variant_id`, and a `recipe_source` flag to force recipes and automated deductions to pull grams/kg/ml from a specific warehouse even if outlets ordinarily consume whole units. Also defines the `damage_unit` so write-offs stay aligned with jar-level handling.

warehouses
----------
Canonical list of all storage locations. Contains `outlet_id` for accountability, `kind`, `active`, and optional `parent_warehouse_id` to express hierarchy (e.g., warehouse groups or sub-rooms).

warehouse_defaults
-------------------
Associates items (and optionally variants) with the warehouse that should fulfill them when orders are approved. Acts as the routing map used by `record_order_fulfillment` when an `order_item` lacks an explicit `warehouse_id`.

outlets
-------
Represents every customer outlet that can place orders. Holds `name`, `code`, selling attributes, and `auth_user_id` which enables “whoami” lookups to find a user’s default outlet context.

outlet_order_counters
----------------------
Generates sequential order numbers per outlet. `next_order_number` inserts/updates this table atomically to keep counters unique.

outlet_deduction_mappings
-------------------------
Defines substitution rules for production deductions. If an outlet sells goods but deductions should hit another outlet or warehouse, this mapping sets `target_outlet_id`/`target_warehouse_id` so stock decrements stay centralized.

orders
------
Outlet purchase orders raised through the mobile app. Contains metadata such as `status`, `order_number`, timestamps, and references to creating/approving users. Each order links to an outlet via `outlet_id`.

order_items
-----------
Line items for each order. Stores `product_id`, optional `variation_id`, both `receiving_uom` and `consumption_uom`, `receiving_contains`, ordered quantity (tracked in consumption units), unit cost, and an optional `warehouse_id` override. Enforces positive `qty` and cascades deletes when a parent order is removed.

outlet_sales
------------
Direct outlet sales/production events captured by scanners. Tracks `outlet_id`, `item_id`, `variant_id`, `qty_units`, `sold_at`, `is_production`, and optional `warehouse_id`. Triggered functions propagate usage into stock balances.

outlet_stock_balances
---------------------
Aggregated ledger of how much stock has been sent versus consumed per outlet/item/variant. Populated by `record_order_fulfillment` (sent side) and `record_outlet_sale` (consumed side). Used for reporting views such as `outlet_stock_summary`.

outlet_stocktakes
-----------------
Stores stocktake counts for outlets. Each row records `warehouse_id`, `product_id`, `counted_qty`, `delta`, `recorded_by`, `recorded_at`, plus optional notes to reconcile manual audits.

stock_ledger
------------
Global warehouse-level ledger listing every movement (`delta_units`) with contextual JSON (`reason`, `context`). All stock adjustments, deductions, and transfers land here so net positions can be rebuilt via the `warehouse_layer_stock` view.

warehouses_admin tables
-----------------------
`stock_movements` / `stock_movement_items` (generated via KSP) feed the warehouse transfer UI. Each transfer has `source_location_id`, `dest_location_id`, status, timestamps, and nested items referencing catalog SKUs.

roles & user_roles
------------------
`roles` defines named permissions (slug, display_name). `user_roles` attaches those roles to users either globally or scoped to an `outlet_id`. The frontend relies on `whoami_roles()` to hydrate current permissions.

platform_admins
----------------
Whitelist table that marks specific Supabase auth users as platform administrators. `is_admin()` simply checks this table. Admins bypass most RLS filters.

warehouse_layer_stock view
--------------------------
Aggregated view over `stock_ledger` grouped by warehouse, stock layer, item, and variant showing net on-hand units for each layer.

outlet_stock_summary view
-------------------------
Joins `outlet_stock_balances` to catalog tables to present per-outlet, per-item/variant sent, consumed, and current on-hand amounts.

How to enter data
=================
1. Supabase SQL editor: paste INSERT statements (see examples in README) and ensure they include mandatory columns listed above. RLS will block writes unless you run them as `service_role` or the policy allows your user.
2. Supabase Table Editor: use the GUI to insert rows table-by-table; ensure foreign-key values already exist (e.g., create `catalog_items` before `catalog_variants`).
3. Seed scripts: run `psql -f supabase/schema.sql` or apply migration snippets to keep environments in sync. This is the safest way for structural changes or large seed batches.
4. App-based entry: mobile/Scanner apps write to `orders`, `order_items`, `outlet_sales`, etc., via RPC helpers (`place_order`, `record_outlet_sale`). Use these flows whenever possible so business logic (numbering, deductions, stock ledger) stays consistent.
